<!DOCTYPE html>
<html lang="pl">
<head>
  <meta charset="UTF-8">
  <title>Piramida 7-kątna - Brass</title>
  <style>
    body { margin: 0; background: #111; color: white; text-align: center; }
    canvas { display: block; margin: 20px auto; background: black; border: 1px solid #444; }
  </style>
</head>
<body>
  <h2>Piramida o podstawie 7-kąta (materiał: Brass)</h2>
  <canvas id="glcanvas" width="600" height="600"></canvas>

  <script src="https://cdn.jsdelivr.net/npm/gl-matrix@3.4.3/gl-matrix-min.js"></script>
  <script>
    const canvas = document.getElementById("glcanvas");
    const gl = canvas.getContext("webgl");

    if (!gl) {
      alert("Twoja przeglądarka nie obsługuje WebGL");
    }

    const vsSource = `
      attribute vec3 aPosition;
      attribute vec3 aNormal;
      uniform mat4 uModelViewMatrix;
      uniform mat4 uProjectionMatrix;
      uniform mat3 uNormalMatrix;
      varying vec3 vNormal;
      varying vec3 vPosition;
      void main(void) {
        vec4 pos = uModelViewMatrix * vec4(aPosition, 1.0);
        vPosition = pos.xyz;
        vNormal = normalize(uNormalMatrix * aNormal);
        gl_Position = uProjectionMatrix * pos;
      }
    `;

    const fsSource = `
      precision mediump float;
      varying vec3 vNormal;
      varying vec3 vPosition;

      uniform vec3 uLightPosition;
      uniform vec4 uAmbient;
      uniform vec4 uDiffuse;
      uniform vec4 uSpecular;
      uniform float uShininess;

      void main(void) {
        vec3 normal = normalize(vNormal);
        vec3 lightDir = normalize(uLightPosition - vPosition);
        vec3 viewDir = normalize(-vPosition);
        vec3 reflectDir = reflect(-lightDir, normal);

        float diff = max(dot(normal, lightDir), 0.0);
        float spec = pow(max(dot(viewDir, reflectDir), 0.0), uShininess);

        vec4 color = uAmbient + uDiffuse * diff + uSpecular * spec;
        gl_FragColor = vec4(color.rgb, 1.0);
      }
    `;

    function compileShader(type, source) {
      const shader = gl.createShader(type);
      gl.shaderSource(shader, source);
      gl.compileShader(shader);
      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        console.error(gl.getShaderInfoLog(shader));
        gl.deleteShader(shader);
        return null;
      }
      return shader;
    }

    const vertexShader = compileShader(gl.VERTEX_SHADER, vsSource);
    const fragmentShader = compileShader(gl.FRAGMENT_SHADER, fsSource);

    const shaderProgram = gl.createProgram();
    gl.attachShader(shaderProgram, vertexShader);
    gl.attachShader(shaderProgram, fragmentShader);
    gl.linkProgram(shaderProgram);

    if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
      console.error("Program shaderów się nie zlinkował");
    }

    gl.useProgram(shaderProgram);

    // Generowanie piramidy
    const sides = 7;
    const radius = 1;
    const height = 1.5;

    const vertices = [0, 0, height]; // wierzchołek
    for (let i = 0; i < sides; i++) {
      const angle = i * 2 * Math.PI / sides;
      vertices.push(Math.cos(angle) * radius, Math.sin(angle) * radius, 0);
    }

    const indices = [];
    for (let i = 1; i <= sides; i++) {
      let next = (i % sides) + 1;
      indices.push(0, i, next); // ściany boczne
    }

    for (let i = 2; i < sides; i++) {
      indices.push(1, i, i + 1); // podstawa
    }

    // Normalne
    function calculateNormals(vertices, indices) {
      const normals = new Array(vertices.length).fill(0);
      for (let i = 0; i < indices.length; i += 3) {
        const i0 = indices[i] * 3;
        const i1 = indices[i + 1] * 3;
        const i2 = indices[i + 2] * 3;

        const v0 = [vertices[i0], vertices[i0 + 1], vertices[i0 + 2]];
        const v1 = [vertices[i1], vertices[i1 + 1], vertices[i1 + 2]];
        const v2 = [vertices[i2], vertices[i2 + 1], vertices[i2 + 2]];

        const u = v1.map((v, j) => v - v0[j]);
        const v = v2.map((v, j) => v - v0[j]);

        const nx = u[1] * v[2] - u[2] * v[1];
        const ny = u[2] * v[0] - u[0] * v[2];
        const nz = u[0] * v[1] - u[1] * v[0];

        for (let j of [i0, i1, i2]) {
          normals[j] += nx;
          normals[j + 1] += ny;
          normals[j + 2] += nz;
        }
      }

      for (let i = 0; i < normals.length; i += 3) {
        const len = Math.hypot(normals[i], normals[i + 1], normals[i + 2]);
        normals[i] /= len;
        normals[i + 1] /= len;
        normals[i + 2] /= len;
      }

      return normals;
    }

    const normals = calculateNormals(vertices, indices);

    function createBuffer(data, attr, size) {
      const buffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(data), gl.STATIC_DRAW);
      const loc = gl.getAttribLocation(shaderProgram, attr);
      gl.vertexAttribPointer(loc, size, gl.FLOAT, false, 0, 0);
      gl.enableVertexAttribArray(loc);
    }

    createBuffer(vertices, "aPosition", 3);
    createBuffer(normals, "aNormal", 3);

    const indexBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);

    // Materiał: Brass
    gl.uniform4fv(gl.getUniformLocation(shaderProgram, "uAmbient"), [0.329, 0.223, 0.027, 1]);
    gl.uniform4fv(gl.getUniformLocation(shaderProgram, "uDiffuse"), [0.780, 0.568, 0.113, 1]);
    gl.uniform4fv(gl.getUniformLocation(shaderProgram, "uSpecular"), [0.992, 0.941, 0.808, 1]);
    gl.uniform1f(gl.getUniformLocation(shaderProgram, "uShininess"), 27.8974);
    gl.uniform3fv(gl.getUniformLocation(shaderProgram, "uLightPosition"), [3, 3, 4]);

    const uModelViewMatrix = gl.getUniformLocation(shaderProgram, "uModelViewMatrix");
    const uProjectionMatrix = gl.getUniformLocation(shaderProgram, "uProjectionMatrix");
    const uNormalMatrix = gl.getUniformLocation(shaderProgram, "uNormalMatrix");

    let angle = 0;
    let dragging = false;
    let lastX = 0;

    canvas.addEventListener("mousedown", e => {
      dragging = true;
      lastX = e.clientX;
    });

    canvas.addEventListener("mouseup", () => dragging = false);
    canvas.addEventListener("mousemove", e => {
      if (dragging) {
        angle += (e.clientX - lastX) * 0.01;
        lastX = e.clientX;
        drawScene();
      }
    });

    function drawScene() {
      gl.viewport(0, 0, canvas.width, canvas.height);
      gl.clearColor(0.1, 0.1, 0.1, 1.0);
      gl.enable(gl.DEPTH_TEST);
      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

      const proj = glMatrix.mat4.create();
      const mv = glMatrix.mat4.create();
      const model = glMatrix.mat4.create();

      glMatrix.mat4.perspective(proj, Math.PI / 4, canvas.width / canvas.height, 0.1, 100);
      glMatrix.mat4.translate(mv, mv, [0, 0, -5]);
      glMatrix.mat4.rotateY(mv, mv, angle);

      const normalMatrix = glMatrix.mat3.normalFromMat4(glMatrix.mat3.create(), mv);

      gl.uniformMatrix4fv(uProjectionMatrix, false, proj);
      gl.uniformMatrix4fv(uModelViewMatrix, false, mv);
      gl.uniformMatrix3fv(uNormalMatrix, false, normalMatrix);

      gl.drawElements(gl.TRIANGLES, indices.length, gl.UNSIGNED_SHORT, 0);
    }

    drawScene();
  </script>
</body>
</html>